# reversed effective dependency on a-layer and t-layer
# excluding numeric constructions
@TEST regexRelationTree@ child :: ok
@TEST regexRelationName@ child -> ok MATCH ARROW (name, not child)
@TEST regexRelationName@ child-> ok MATCH ARROW (name, not child)
@TEST regexRelationName@ d/d -> ok
@TEST regexRelationName@ error $x :=
@TEST regexRelationName@ ok $x 
@TEST regexRelationName@ ok name $variable
@TEST regexRelationName@ ok name [

# toplevel_selector
  t $v := [];
+ t $v := [];
    $v := [];
+   $v := [];
  t       [];
+ t       [];
          [];
+         [];

# optional_nested_selector, nested_selector
# \?? +? RELATION? type? name_assignment? [ ...
a [ ? + child t $v := []];
a [ ? + child t       []];
a [ ? + child   $v := []];
a [ ? + child         []];
a [ ? +       t $v := []];
a [ ? +       t       []];
a [ ? +         $v := []];
a [ ? +               []];
a [ ?   child t $v := []];
a [ ?   child t       []];
a [ ?   child   $v := []];
a [ ?   child         []];
a [ ?         t $v := []];
a [ ?         t       []];
a [ ?           $v := []];
a [ ?                 []];
a [   + child t $v := []];
a [   + child t       []];
a [   + child   $v := []];
a [   + child         []];
a [   +       t $v := []];
a [   +       t       []];
a [   +         $v := []];
a [   +               []];
a [     child t $v := []];
a [     child t       []];
a [     child   $v := []];
a [     child         []];
a [           t $v := []];
a [           t       []];
a [             $v := []];
a [                   []];

# RELATION
a [ child [], parent [], same-tree-as [], same-document-as []];
a [ child :: [], parent ::[], same-tree-as :: [], same-document-as :: []];
a [ sibling [], descendant [], ancestor []];
a [ sibling :: [], descendant :: [], ancestor :: []];
a [ sibling{,} [], descendant{-1,} [], ancestor{,-9} []];
a [ sibling{1,1} :: [], descendant{1,} :: [], ancestor{,9} :: []];
a [ depth-first-precedes [], depth-first-follows [], order-precedes [], order-follows []];
a [ depth-first-precedes :: [], depth-first-follows :: [], order-precedes :: [], order-follows :: []];
a [ depth-first-precedes{1,1} [], depth-first-follows{1,1} [], order-precedes{1,1} [], order-follows{1,1} []];
a [ depth-first-precedes{1,1} :: [], depth-first-follows{1,1} :: [], order-precedes{1,1} :: [], order-follows{1,1} :: []];
# /[_a-zA-Z][-.\/_a-zA-Z]*(?=\s*->|\s*\$[[:alpha:]_][[:alnum:]_]*\b(?!\s*:=)|\s+${Treex::PML::Schema::CDATA::Name}\s*(?:\[|\$))/ /\s*(?!::)(->)?/
a[ a/. -> []];
a[ a/. $x ];
a[ a/. -> $x ];
a[ a/. CDATA_name [ ] ];
a[ a/. -> CDATA_name [ ] ];
#a[ a/. CDATA_name $x ];
#a[ a/. -> CDATA_name $x ];
# /[_a-zA-Z][-.\/_a-zA-Z]*(?=(?:\{[0-9]*,[0-9]*\})(?:\s*->|\s*\$[[:alpha:]_][[:alnum:]_]*\b(?!\s*:=)|\s+${Treex::PML::Schema::CDATA::Name}\s*(?:\[|\$)))/ <skip:''> '{' <commit> <skip:'\s*(?:[#][^\n]*\s*)*'> (/[0-9]+/)(?) ',' (/[0-9]+/)(?) '}' /\s*(?!::)(->)?/

# member
a [         member [2]a/content()       []];
a [         member a[2]/.         $x := []];
a [!        member a/b/c/d              []];
a [!        member a/[ 5 ]        $x := []];
a [! 5..10x member content()/.          []];
a [! 5..10x member []             $x := []];





z-node $n := [ child z-node $m := [ *a != b/c + *$n.d/e/f ] ];

a[ 1+1=2-1 or 'a' = 'a' and 1 != 1];
a[ x/c = 'a' or x/c = 'a' and x/c = 'a'];

a[ x/c =   'a'];
a[ x/c in  {'a','b'}];

t-node $t:= [ a/lex.rf -> a-node $a:= [ afun='Sb' ], a/aux.rf a-node $x:= [ afun = 'AuxP' ] ];

t-node $a := [ 
    typeprefix attribute/[5] = 1,
    gram/sempos='v',
    ! child t-node [ functor in { 'ACT','PAT','ADDR','ORIG','EFF' } ]
];
t-node $n:= [
  member bridging [
    informaltype = "CONTRAST",
    t-node [ functor="ACT" ]
  ]
];
a-node $A := [
  m/tag !~ '^C',
  child a-node $B := [
    m/tag !~ '^C'] ];
t-node [
  a/lex.rf $B,
  child t-node [ a/lex.rf $A ] ];
a-node [ 
  afun = 'AuxV',
  ancestor a-root $r := [ 
    + descendant a-node $a := [  ] ] ];

t-node $t := [
  descendant t-node [
    sons()=0,
    depth_first_order()-depth()=depth_first_order($t)-depth($t)
  ]
];

t-node $ref1 := [ 
  parent t-node $ref0 := [ 
    1+x same-tree-as t-node $ref2 := [ 
      !ancestor $ref0, 
      ((order-follows $ref0 and order-precedes $ref1) 
        or (order-follows $ref1 and order-precedes $ref0)) 
      ] ] ];

t-node $p := [ child t-node $c :=  [  ] ];
>>  for $p.functor,$c.functor
  give $1,$2,ratio(count() over $1)
  sort by $1,$3 desc
>> $1,$2,$3, row_number(over $1)
>> filter $4<=2 
