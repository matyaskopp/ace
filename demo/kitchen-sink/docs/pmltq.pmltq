# reversed effective dependency on a-layer and t-layer
# excluding numeric constructions
@TEST regexRelationTree@ child :: ok
@TEST regexRelationName@ child -> ok MATCH ARROW (name, not child)
@TEST regexRelationName@ child-> ok MATCH ARROW (name, not child)
@TEST regexRelationName@ d/d -> ok
@TEST regexRelationName@ error $x :=
@TEST regexRelationName@ ok $x 
@TEST regexRelationName@ ok name $variable
@TEST regexRelationName@ ok name [



a [ 
] ;
a [ b [ 
] ] ;

a[         member [2]a/content()       []];
a[         member a[2]/.         $x := []];
a[!        member a/b/c/d              []];
a[!        member a/[ 5 ]        $x := []];
a[! 5..10x member content()/.          []];
a[! 5..10x member []             $x := []];

z-node $n := [ child z-node $m := [ *a != b/c + *$n.d/e/f ] ];

a[ 1+1=2-1 or 'a' = 'a' and 1 != 1];
a[ x/c = 'a' or x/c = 'a' and x/c = 'a'];

a[ x/c =   'a'];
a[ x/c in  {'a','b'}];

t-node $t:= [ a/lex.rf -> a-node $a:= [ afun='Sb' ], a/aux.rf a-node $x:= [ afun = 'AuxP' ] ];

t-node $a := [ 
    typeprefix attribute/[5] = 1,
    gram/sempos='v',
    ! child t-node [ functor in { 'ACT','PAT','ADDR','ORIG','EFF' } ]
];
t-node $n:= [
  member bridging [
    informaltype = "CONTRAST",
    t-node [ functor="ACT" ]
  ]
];
a-node $A := [
  m/tag !~ '^C',
  child a-node $B := [
    m/tag !~ '^C'] ];
t-node [
  a/lex.rf $B,
  child t-node [ a/lex.rf $A ] ];
a-node [ 
  afun = 'AuxV',
  ancestor a-root $r := [ 
    + descendant a-node $a := [  ] ] ];

t-node $t := [
  descendant t-node [
    sons()=0,
    depth_first_order()-depth()=depth_first_order($t)-depth($t)
  ]
];

t-node $ref1 := [ 
  parent t-node $ref0 := [ 
    1+x same-tree-as t-node $ref2 := [ 
      !ancestor $ref0, 
      ((order-follows $ref0 and order-precedes $ref1) 
        or (order-follows $ref1 and order-precedes $ref0)) 
      ] ] ];

t-node $p := [ child t-node $c :=  [  ] ];
>>  for $p.functor,$c.functor
  give $1,$2,ratio(count() over $1)
  sort by $1,$3 desc
>> $1,$2,$3, row_number(over $1)
>> filter $4<=2 
