# reversed effective dependency on a-layer and t-layer
# excluding numeric constructions
a [ ] ;
a [ [ ] ] ;
a [ b [ [ [ ] ] ] ] ;

a[         member [2]a/content()       []];
a[         member a[2]/.         $x := []];
a[!        member a/b/c/d              []];
a[!        member a/[ 5 ]        $x := []];
a[! 5..10x member content()/.          []];
a[! 5..10x member []             $x := []];

a[ x/c =   'a'];
a[ x/c in  {'a','b'}];


t-node $a := [ 
    gram/sempos='v',
    ! child t-node [ functor in { 'ACT','PAT','ADDR','ORIG','EFF' } ]
];
t-node $n:= [
  member bridging [
    informal-type = "CONTRAST",
    target-node.rf t-node [ functor="ACT" ]
  ]
];
a-node $A := [
  m/tag !~ '^C',
  child a-node $B := [
    m/tag !~ '^C'] ];
t-node [
  a/lex.rf $B,
  child t-node [ a/lex.rf $A ] ];
a-node [ 
  afun = 'AuxV',
  ancestor a-root $r := [ 
    + descendant a-node $a := [  ] ] ];

t-node $t := [
  descendant t-node [
    sons()=0,
    depth_first_order()-depth()=depth_first_order($t)-depth($t)
  ]
];

t-node $ref1 := [ 
  parent t-node $ref0 := [ 
    1+x same-tree-as t-node $ref2 := [ 
      !ancestor $ref0, 
      ((order-follows $ref0 and order-precedes $ref1) 
        or (order-follows $ref1 and order-precedes $ref0)) 
      ] ] ];

t-node $p := [ child t-node $c :=  [  ] ];
>>  for $p.functor,$c.functor
  give $1,$2,ratio(count() over $1)
  sort by $1,$3 desc
>> $1,$2,$3, row_number(over $1)
>> filter $4<=2 
